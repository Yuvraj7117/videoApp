'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fetchWrapper;
function fetchWrapper() {
  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var attempt = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
  var retryIntervals = arguments.length <= 2 || arguments[2] === undefined ? retryIntervals : arguments[2];

  var onFetchSuccess = options.onSuccess;
  var onFetchFail = onFail.bind(null, options, attempt, options.retryIntervals || retryIntervals);
  var onError = handleError.bind(null, options, attempt);

  options.request().then(parseResponse.bind(null, options), onFetchFail) // catch errors from fetch request
  .then(onFetchSuccess, onError) // catch errors from status codes or parsing data in onFetchComplete
  .catch(onError); // catch errors from onSuccess or parsing data
}

var retryIntervals = [1000]; // default value of the time intervals at which to retry the request

var onFail = exports.onFail = function onFail(options, attempt, error) {
  if (retryIntervals[attempt]) {
    setTimeout(function () {
      return fetchWrapper(options, ++attempt);
    }, retryIntervals[attempt]);
  } else {
    var status = error.response ? error.response.status : 'error'; // Treat network errors without responses as 500s (internal server error).
    var message = error.message;
    return options.onError({ status: status, message: message });
  }
};

var parseResponse = exports.parseResponse = function parseResponse(options, res) {
  var type = options.responseType;

  if (type && type == 'text') {
    return res.text();
  } else if (type && type == 'json') {
    return res.json();
  } else {
    throw new Error('Invalid Response Type');
  }
};

var handleError = function handleError(options, attempt, error) {
  var errorMessage = error.toString();
  if (errorMessage === 'SyntaxError: Unexpected end of input') {
    options.onSuccess({ status: 'error', message: 'No response body' }); // error in res.json/res.text
  } else if (errorMessage === 'Error: Invalid Response Type') {
      options.onSuccess({ status: 'error', message: 'Invalid Response Type' }); // error in options for fetch wrapper
    } else {
        return options.onError({ status: 'error', message: errorMessage });
      }
};